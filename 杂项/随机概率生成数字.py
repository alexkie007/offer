"""
rand3()可以随机等概率生成1，2，3
请使用rand3()构造rand7()可以随机等概率生成1，2，3，4，5，6，7
"""
"""
解题思路：
rand3可以随机生成1,2,3；rand7可以随机生成1,2,3,4,5,6,7。 
rand3并不能直接产生4,5,6，7，所以直接用rand3去实现函数rand7似乎不太好入手。 
如果反过来呢？给你rand7，让你实现rand3，这个好实现吗？
int Rand3(){
    int x = ~(1<<31); // max int
    while(x > 3)
        x = Rand7();
    return x;
}
述计算说明Rand3是等概率地生成1,2,3的(1/3的概率)

回到正题，现在题目要求我们要用Rand5来实现Rand7，
只要我们将Rand5 映射到一个能产生更大随机数的Randa，
其中a > 7，就可以套用上面的模板了。 这里要注意一点的是，
你映射后的Randa一定是要满足等概率生成1到a的。比如，
Rand5() + Rand5() - 1

上述代码可以生成1到9的数，但它们是等概率生成的吗？不是。生成1只有一种组合： 
两个Rand5()都生成1时：(1, 1)；而生成2有两种：(1, 2)和(2, 1)；生成6更多。 它们的生成是不等概率的。那要怎样找到一个等概率生成数的组合呢？
我们先给出一个组合，再来进行分析。组合如下：
5 * (Rand5() - 1) + Rand5()
Rand5产生1到5的数，减1就产生0到4的数，乘以5后可以产生的数是：0,5,10,15,20。 再加上第二个Rand5()产生的1,2,3,4,5。我们可以得到1到25， 
而且每个数都只由一种组合得到，即上述代码可以等概率地生成1到25。OK， 到这基本上也就解决了。

套用上面的模板，我们可以得到如下代码：

int Rand7(){
    int x = ~(1<<31); // max int
    while(x > 7)
        x = 5 * (Rand5() - 1) + Rand5() 
    return x;
}
上面的代码有什么问题呢？可能while循环要进行很多次才能返回。 
因为Rand25会产生1到25的数，而只有1到7时才跳出while循环，
 生成大部分的数都舍弃掉了。这样的实现明显不好。
 我们应该让舍弃的数尽量少， 于是我们可以修改while中的判断条件，
 让x与最接近25且小于25的7的倍数相比。 于是判断条件可改为x > 21，
 于是x的取值就是1到21。 我们再通过取模运算把它映射到1-7即可。代码如下：
int Rand7(){
    int x = ~(1<<31); // max int
    while(x > 21)
        x = 5 * (Rand5() - 1) + Rand5() 
    return x%7 + 1;
}
因此我们可以先生成rand5 然后用rand5生成rand7


从上面一系列的分析可以发现，如果给你两个生成随机数的函数Randa和Randb， 你可以通过以下方式轻松构造Randab，生成1到a*b的随机数。

Randab = b * (Randa - 1) + Randb
Randab = a * (Randb - 1) + Randa

"""
